import { LogLevel } from "../utils/logger";
import { TemplateContent } from "./render-engine";

export interface ConversionConfig {

  /**
   * The template to use for the conversion
   * you can either provide a folder path or a template content
   * 
   * @example:
   * ```typescript
   * template: {
   *   folderPath: './templates/dart'
   * }
   * ```
   * 
   * or
   * 
   * @example:
   * ```typescript
   * template: {
   *   content: {
   *      [TemplateType.Function]: 'content for function template',
   *      ....
   *      // Similarly for other templates as well
   *   }
   * }
   * ```
   */
  template?: TemplateContent;

  /**
   * This is used to map the typescript types to the target language types
   * Specially useful for mapping primitive types to their target language equivalents.
   * 
   * @example:
   * ```typescript
   * typeMappings: {
   *   'number': 'Int32'
   * }
   * 
   * This will map all the `number` types to `Int32` in the target language output
   * 
   * 
   */
  typeMappings?: Record<string, string>;

  /**
   * While converting all the inline types are given
   * a dynamic name, this function can be used to format the name
   * 
   * @param names - The names of the inline type's path
   * 
   * Eg: 
   * ```typescript
   * type MyType = {
   *   field: { nestedField: string } 
   * }
   * 
   * The function will be called with the following arguments:
   * ```typescript
   * ['MyType', 'field']
   * ```
   * 
   * The default inlineTypeNameFormatter will return `MyType__field`
   * 
   * ```typescript
   * type MyType = {
   *   field: MyType__field
   * }
   * ```
   * 
   * @returns The formatted name
   * 
   * @example
   * ```typescript
   * runtimeNameFormatter: (...names: string[]) => names.join('__')
   * ```
   */
  inlineTypeNameFormatter?: (...names: string[]) => string;

  /**
   * Types to skip to be converted
   * 
   * @example
   * ```typescript
   * skipTypes: ['ToSkip']
   * ```
   */
  skipTypes?: string[];

  /**
   * Lines to append to the generated file
   * 
   * @example
   * ```typescript
   * headerContent: `generated by @ts-to-any-converter`
   *
   * ```
   */
  headerContent?: string;

  /**
   * Lines to append to the generated file
   */
  footerContent?: string;

  /**
   * Additional flags to be added to the generated file
   * This will available in the mustache template as `_flags`
   * @example
   * ```typescript
   * additionalFlags: {
   *   'useJsonSerializable': 'true'
   * }  
   * ```
   */
  additionalFlags?: Record<string, string>;
}

export interface InputConfig {
  /**
   * The input files to convert
   */
  inputFiles: string[];
}

/**
 * Configuration for the TypeScript converter
 * @remarks
 * The language configuration can be specified in two ways:
 * 1. Using a custom template path
 * 2. Using one of the default language templates
 * 
 * @example
 * ```typescript
 * // Using default templates
 * const config: ConverterConfig = {
 *   inputFiles: ['./src/types.ts'],
 *   language: {
 *     defaultTemplate: DefaultLanguage.Dart
 *   }
 * }
 * 
 * // Using custom templates
 * const config: ConverterConfig = {
 *   inputFiles: ['./src/types.ts'],
 *   language: {
 *     customTemplatePath: './my-templates'
 *   }
 * }
 * ```
 */
export interface ConverterConfig {
  /**
   * The input configuration
   */
  inputConfig?: InputConfig;

  /**
   * The conversion configuration
   */
  conversionConfig: ConversionConfig;

  /**
   * The log level to use
   * @default LogLevel.Info
   */
  logLevel?: LogLevel;
}
